---
layout: post
title: Mars Maps
tags: [sweeping, segment]
---
## Problem

[https://www.acmicpc.net/problem/3392](https://www.acmicpc.net/problem/3392)

## Summary

N(1 ≤ N ≤ 10,000),  (x1, y1)와 (x2, y2)은 직사각형의 왼쪽 아래 좌표와 오른쪽 위 좌표<br>
x1, y1, x2, y2 (0 ≤ x1 < x2 ≤ 30,000, 0 ≤ y1 < y2 ≤ 30,000)

## Idea

### native

N^3<br>
``` c
for (x 만큼){
    for (y 만큼) {
        for (직사각형 개수 n만큼) {
            if (x,y가 큰 직사각형에 포함되는지) {
                sum update
            }
        }
    }
}
```

### flood fill

직사각형에 카운트 1을 채운다. 중복된 영역은 카운트 +1 을 해 최종적으로 카운트 1을 센다


### plane sweeping with segment tree

<img src="https://www.acmicpc.net/upload/images/8vR77Ew2O2PqvZ1lER716.png"><br>

* 각각의 직사각형의 시작 면(왼쪽면)과 끝면(오른쪽 면)을 list에 담아 x축으로 오름차순 정렬<br>
시작면 x1,y1,y2,1<br>
끝면 x2,y1,y2,-1<br>

``` java
for (int i = 0; i < N; i++) {
    st = new StringTokenizer(br.readLine(),  " ");

    int x1 = Integer.parseInt(st.nextToken());
    int y1 = Integer.parseInt(st.nextToken());
    int x2 = Integer.parseInt(st.nextToken());
    int y2 = Integer.parseInt(st.nextToken());

    points[2*i] = new Point(x1, y1, y2, 0);
    points[2*i+1] = new Point(x2, y1, y2, 1);
}

Arrays.sort(points);
```

* x좌표를 sweep 하면서 넓이를 구해간다

- x를 하나 꺼내 세로선 업데이트<br>
세로선이 시작선일 경우, 해당 구간의 노드 값을 1 증가<br>
새로선이 끝 선일 경우, 해당 구간의 노드 값을 1 감소<br>

- 면적을 구한다
(x - 이전 x) * 높이 (= tree leaf 노드가 1 이상인 개수)<br>

복잡도를 대략 계산해 보면:<br>
query: log30000 (= 2^16 = 65536이니 15승 정도) = 15<br>
update: 30000 * log30000 = 30000 * 15 = 45만<br>

총: 20000 * 45만 = 대략 90억 <br>

세로 선 업데이트 시 최대 30000 번 이루어질 수 있어 lazy update가 필요하다

## Related
* [https://www.acmicpc.net/problem/2669](https://www.acmicpc.net/problem/2669)
* [https://www.acmicpc.net/problem/2185](https://www.acmicpc.net/problem/2185)
* [Painting patter](https://www.acmicpc.net/problem/7728)
* [도서실카펫](https://www.acmicpc.net/problem/2601)
