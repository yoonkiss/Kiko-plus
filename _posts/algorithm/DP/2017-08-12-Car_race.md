---
layout: post
title: 자동차 경주
category: [Algorithm]
tags: [dp,ts]
---
### [자동차경주](https://www.acmicpc.net/problem/2611)

dist[curr]: curr 에서의 최대 값 저장

도착점 1로부터 거꾸로 본다.<br>
정점 2에서의 최대 값은 정점 5(next 값)에서 2를 보는 것 과 정점 5에서 2를 보는 값 들 중에 최대값으로 갱신<br>

``` java
static int f(int curr) {
    if (dist[curr] != 0  || curr == 1) {
        return dist[curr];
    }

    for (V next : adj.get(curr)) {
        int w = f(next.to) + next.w;
        if (w > dist[curr]) {
            dist[curr] = w;
            trace[curr] = next.to;
        }
    }
    
    return dist[curr];
}
// 혹은, 일단 끝까지 가고, 백트랙하면서 업데이트 하는 방법가능

static void dfs1(int curr) {
    for (V next : adj.get(curr)) {
        if (dp[next.to] == 0) {
            dfs1(next.to);
        }

        int w = dp[next.to] + next.w;
        if (w > dp[curr]) {
            dp[curr] = w;
        }
    }
}

// 다시 DFS로 시작점부터 if (w == dp[curr]) 이면? curr은 최장(최대) 거리를 지나는 놈이다
static void dfs2(int curr) {
    if (ck[curr] == 0) {
        ck[curr] = 1;

        for (V next : adj.get(curr)) {
            int w = dp[next.to] + next.w;
            if (w == dp[curr]) {
                dfs2(next.to);
                ans++;
            }
        }
    }
}
```
